# 核心技术实现

本页聚焦“为什么这样设计、关键流程怎么跑、失败如何处理”。

## 1. 模块划分与职责

- `pyside_switcher.py`
  - 各功能页面（UI + 交互）
  - 后台任务线程调度
  - 页面间状态刷新与导航联动
- `codex_switcher.py`
  - 账号存储读写
  - 配置文件与认证文件更新
  - 命令发现、网络探测、日志记录

这种划分让 UI 逻辑与底层能力解耦：页面只负责“编排”，底层函数负责“落地”。

## 2. 状态模型与页面协作

`AppState` 作为共享状态容器，保存：

- 当前账号
- codex 路径/版本
- VS Code 安装目录

页面通过 `on_show()` 实现“进入即刷新”，并在关键写操作后调用全局刷新，保证跨页面一致性。

## 3. 并发模型：后台线程 + UI 回调

耗时动作（网络请求、磁盘扫描、版本查询、深度搜索）放入后台线程执行，完成后通过 `run_in_ui(...)` 回主线程更新控件。

价值：

- 界面不会因长任务卡死
- UI 更新集中在主线程，规避线程安全问题

## 4. 账号应用链路（关键数据流）

“应用账号”不是只改内存，而是完整落盘流程：

1. 更新 `config.toml` 的 provider `base_url`
2. 更新 `auth.json` 的 `OPENAI_API_KEY`
3. Team 写入 `OPENAI_ORG_ID`，非 Team 清理该字段
4. 更新 `codex_profiles.json` 的 active 指针

其中 `safe_write_text(...)` 在 Windows 下会处理隐藏/只读属性，提升写入成功率。

## 5. 中转站诊断：从连通到语义有效

入口函数是 `probe_endpoints(...)`，其设计不是“简单 ping 一下”，而是分层诊断：

- 网络层：Ping、HEAD、443 端口
- 接口层：多端点请求（含 `/v1` 变体）
- 语义层：响应结构校验（字段完整性、错误对象检测）

因此可区分：

- 网络不通
- 接口存在但不可用
- 接口返回 200 但业务响应无效
- 模型不在可用列表或被策略限制

## 6. VSCode 增模补丁：分级容错策略

增模入口：`VSCodePluginPage.apply_patch()`。

补丁顺序：

1. `_apply_allowlist_patch`（关键）
2. `_apply_apikey_filter_patch`（关键）
3. `_apply_apikey_order_inject_patch`（增强）
4. `_apply_initial_data_patch`（增强）

判定策略：

- 关键补丁失败：直接中止，不写入文件
- 增强补丁失败：允许写入，并明确提示“部分规则未更新”

写入前会先生成备份，满足“可回滚”要求。

## 7. 会话检索：两阶段搜索

入口：`SessionManagerPage.apply_filter()`。

阶段一：先用 `history.jsonl` 快速匹配（低成本）。  
阶段二：无命中时回退原始会话文件深度搜索（高覆盖）。

同时支持：

- AND/OR 模式
- 最近 N 天
- 最大扫描数量
- 取消搜索

这是典型的“先索引后回退”检索策略，兼顾速度与召回率。

## 8. VS Code 会话继续：URI 直达 + 回退

会话继续到 VS Code 时，先尝试 URI 直达会话 ID；若环境不支持或失败，则自动回退为“打开对应工作目录”。

这使功能具备更强兼容性：

- 支持直达时体验最佳
- 不支持直达时仍可保障可用

## 9. 更新检查与导航红点

更新页通过 GitHub Releases API 获取最新版本，并计算版本差异数量。结果通过导航按钮徽标反馈，形成“后台自动检查 + 前台可见提醒”的闭环。
